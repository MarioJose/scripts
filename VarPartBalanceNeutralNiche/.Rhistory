boxplot(dt$x~dt$site)
source('~/Git/r-functions/plot.scatter.box/plot.scatter.box.r')
plot.scatter.box(x=dt$x, g1=dt$site, g2=dt$sp)
plot.scatter.box(x=dt$x, g1=dt$site, g2=dt$sp, pcol="blue", mcol="black")
dt <- data.frame(x=c(rnorm(100, 5, 2), rnorm(100, 10, 3), rnorm(100, 7, 5)), site=c(rep("BD", 100), rep("IS", 100), rep("OT", 100)), sp=sample(paste("sp", 1:20, sep=""), 300, replace = TRUE, prob = 20:1))
plot.scatter.box(x=dt$x, g1=dt$site, g2=dt$sp)
plot.scatter.box(x=dt$x, g1=dt$site, g2=dt$sp, hlg = c("sp1", "sp14"), hlc = c("blue", "red"))
dt <- data.frame(x=c(rnorm(100, 5, 2), rnorm(100, 10, 3)), site=c(rep("BD", 100), rep("IS", 100)), sp=sample(paste("sp", 1:20, sep=""), 200, replace = TRUE, prob = 20:1))
plot.scatter.box(x=dt$x, g1=dt$site, g2=dt$sp, hlg = c("sp1", "sp14"), hlc = c("blue", "red"))
source('~/Git/r-functions/plot.scatter.box/plot.scatter.box.r')
plot.scatter.box(x=dt$x, g1=dt$site, g2=dt$sp, hlg = c("sp1", "sp14"), hlc = c("blue", "red"))
par(mar(4,4,1,1))
par(mar=c(4,4,1,1))
plot.scatter.box(x=dt$x, g1=dt$site, g2=dt$sp, hlg = c("sp1", "sp14"), hlc = c("blue", "red"))
png("scatter.box.png", 7, 7)
plot.scatter.box(x=dt$x, g1=dt$site, g2=dt$sp, hlg = c("sp1", "sp14"), hlc = c("blue", "red"))
png("scatter.box.png", 350, 350)
par(mar=c(4,4,1,1))
plot.scatter.box(x=dt$x, g1=dt$site, g2=dt$sp, hlg = c("sp1", "sp14"), hlc = c("blue", "red"))
dev.off()
getwd()
png("scatter.box.png", 350, 350)
par(mar=c(4,4,1,1), cex=1.3)
plot.scatter.box(x=dt$x, g1=dt$site, g2=dt$sp, hlg = c("sp1", "sp14"), hlc = c("blue", "red"))
dev.off()
png("scatter.box.png", 350, 350)
par(mar=c(4,4,1,1), cex=1.5)
plot.scatter.box(x=dt$x, g1=dt$site, g2=dt$sp, hlg = c("sp1", "sp14"), hlc = c("blue", "red"))
dev.off()
png("scatter.box.png", 350, 350)
par(mar=c(4.1,4,1,1), cex=1.5)
plot.scatter.box(x=dt$x, g1=dt$site, g2=dt$sp, hlg = c("sp1", "sp14"), hlc = c("blue", "green"))
dev.off()
dt <- matrix(1:25,5,5)
rownames(dt) <- paste("sp", 1:5)
rownames(dt)
rownames(dt[2,])
rownames(dt[2,])dt
dt[2,]
freq_p <- matrix(1:10, nrow = 10)
View(freq_p)
set.seed(42)
especies <- paste("sp", 1:15, sep="")
# Estou inventando os dados com os nomes das especies
freq_p <- matrix(1:10, nrow = 10)
freq_d <- matrix(11:20, nrow = 10)
rownames(freq_p) <- paste(sample(especies, 10))
rownames(freq_d) <- paste(sample(especies, 10))
View(freq_d)
View(freq_p)
rownames(freq_p)[rownames(freq_p) %in% rownames(freq_d)]
spp_corresp <- rownames(freq_p)[rownames(freq_p) %in% rownames(freq_d)]
spp_corresp <- rownames(freq_p)[rownames(freq_p) %in% rownames(freq_d)]
rownames(nova) <- spp_corresp
colnames(nova) <- c("freq_p", "freq_d")
nova <- matrix(NA, nrow = length(spp_corresp), ncol = 2)
rownames(nova) <- spp_corresp
colnames(nova) <- c("freq_p", "freq_d")
View(nova)
nova$freq_d
nova[ ,"freq_d"]
nova[ ,"freq_p"] <- freq_p[match(rownames(nova), rownames(freq_p)),1]
nova[ ,"freq_d"] <- freq_d[match(rownames(nova), rownames(freq_d)),1]
View(nova)
View(freq_d)
View(freq_p)
length(freq_d[ ,])
length(unique(rownames(freq_d)))
length(freq_p[ ,])
length(unique(rownames(freq_p)))
nova[ ,"sub"] <- nova[ ,"freq_p"] - nova[ ,"freq_d"]
nova[ ,"freq_p"]
nova[ ,"freq_p"] - nova[ ,"freq_d"]
nova$sub <- nova[ ,"freq_d"] - nova[ ,"freq_p"]
dt
View(freq_d)
set.seed(42)
especies <- paste("sp", 1:15, sep="")
# Estou inventando os dados com os nomes das especies
freq_p <- matrix(1:10, nrow = 10)
freq_d <- matrix(11:20, nrow = 10)
rownames(freq_p) <- paste(sample(especies, 10))
rownames(freq_d) <- paste(sample(especies, 10))
# Especies que estao nas duas matrizes
spp_corresp <- rownames(freq_p)[rownames(freq_p) %in% rownames(freq_d)]
# Cria nova matriz somente com as especies que estao nas duas matriz de freq.
nova <- matrix(NA, nrow = length(spp_corresp), ncol = 2)
rownames(nova) <- spp_corresp
colnames(nova) <- c("freq_p", "freq_d")
# Agora vamos adicionar os valores nos lugares certos. Como voce falou que as matrizes
#   so tem uma coluna, estou aceitando que a coluna 1 e a que tem os dados
nova[ ,"freq_p"] <- freq_p[match(rownames(nova), rownames(freq_p)),1]
nova[ ,"freq_d"] <- freq_d[match(rownames(nova), rownames(freq_d)),1]
View(nova)
nova$freq_p
is.recursive(nova)
help($)
help("$")
names(nova)
class(nova)
nova <- cbind(nova, sub=nova[ ,"freq_d"] - nova[ ,"freq_p"]
)
View(nova)
install.packages(c("chron", "curl", "dplyr", "manipulate", "plyr", "RefManageR", "rmarkdown", "sads", "scales", "shiny", "taxize"))
library(sads)
fitweibull
l1 <- list(a=1, b=2)
l2 <- c(list(2, start = list(c=3,d=4)
))
l2
class(l1)
class(l2)
l1$a
l2$b
l2$c
ls
l2
l2$start$c
f <- (ll, st, ...){
tmp <- c(ll, start=ll, ...)
print(class(tmp))
f <- (ll, st, ...){
f <- function(ll, st, ...){
tmp <- c(ll, start=ll, ...)
print(class(tmp))
}
f(function(x)cat(x), list(a=1,b=2), control=list(par=2))
f <- function(ll, st, ...){
tmp <- c(ll, start=ll, ...)
print(tmp)
}
f(function(x)cat(x), list(a=1,b=2), control=list(par=2))
dt <- rweibull(100, 0.8, 2)
fitweibull(dt)
dt
fitweibull(dt)
mle2(function(x,shape,scale)-sum(dweibull(x,shape,scale)), start = list(shape=0.4, scale=1.5))
mle2(function(x,shape,scale)-sum(dweibull(x,shape,scale)), start = list(shape=0.4, scale=1.5), data=list(x=dt))
fitweibull
mle2(function(x,shape,scale)-sum(dweibull(x,shape,scale)), start = list(shape=0.4, scale=1.5), data=list(x=dt))
mle2(function(x,shape,scale)-sum(dweibull(x,shape,scale,log=TRUE)), start = list(shape=0.4, scale=1.5), data=list(x=dt))
mle2(function(x,shape,scale)-sum(dweibull(x,shape,scale,log=TRUE)), start = list(shape=0.4, scale=1.5), data=list(x=dt), control=list(parscale=list(shape=0.4,scale=2)))
mle2(function(x,shape,scale)-sum(dweibull(x,shape,scale,log=TRUE)), start = list(shape=0.4, scale=1.5), data=list(x=dt), control=list(parscale=c(shape=0.4,scale=2)))
fitweibull(dt)
debugSource('~/Downloads/fitweibull.r')
debugSource('~/Downloads/fitweibull.r')
fitweibull2 <- function (x, trunc, start.value, ...)
debugSource('~/Downloads/fitweibull.r')
source('~/Downloads/fitweibull.r')
source('~/Downloads/fitweibull.r')
source('~/Downloads/fitweibull.r')
source('~/Downloads/fitweibull.r')
detach("package:sads", unload=TRUE)
library("sads", lib.loc="~/R/Library")
source('~/.active-rstudio-document')
debugSource('~/Downloads/fitweibull.r')
debugSource('~/Downloads/fitweibull.r')
debugSource('~/Downloads/fitweibull.r')
library(sads)
source('~/.active-rstudio-document')
debugSource('~/Downloads/fitweibull.r')
debugSource('~/Documents/biologia/pos/articles/SAD soil gradient/R/plot_mle_profile.r')
debugSource('~/Downloads/fitweibull.r')
debugSource('~/Downloads/fitweibull.r')
debugSource('~/Downloads/fitweibull.r')
fitweibull2(dt)
dt <- rweibull(100, shape = 0.8, scale = 2)
fitweibull2(dt)
set.seed(42)
dt <- rweibull(100, shape = 0.8, scale = 2)
fitweibull(dt)
set.seed(42)
dt <- rweibull(100, shape = 0.8, scale = 2)
fitweibull(dt)
plot(density(dt))
source('~/Downloads/fitweibull.r')
fitweibull(dt)
fitweibull2(dt)
source('~/Downloads/fitweibull.r')
fitweibull(dt)
fitweibull2(dt)
source('~/Downloads/fitweibull.r')
source('~/Downloads/fitweibull.r')
fitweibull(dt)
fitweibull2(dt)
fitweibull(dt, start.value = list(shape=0.7, scale=1.8))
fitweibull(dt, start.value = c(shape=0.7, scale=1.8))
fitweibull(dt, start.value = c(shape=0.7, scale=1.8), control=list(parscale=c(shape=0.7, scale=1.8)))
fitweibull(dt, start.value = c(shape=0.7, scale=1.8), control=list(parscale=list(shape=0.7, scale=1.8)))
fitweibull(dt, start.value = c(shape=0.7, scale=1.8), control=list(parscale=list(shape=0.79, scale=1.99)))
fitweibull(dt, start.value = c(shape=0.7, scale=1.8), control=list(parscale=c(shape=0.79, scale=1.99)))
l2 <- c(list(2, start = list(c=3,d=4)), list(control=parscale=c(a=1,b=2)))
l2 <- c(list(2, start = list(c=3,d=4)), list(control=list(parscale=c(a=1,b=2))))
l2
l2$control$parscale
l2$control$parscale$a
l2 <- list(list(2, start = list(c=3,d=4)), list(control=list(parscale=c(a=1,b=2))))
l2$control$parscale$a
l2$control$parscale$a
l2$control$parscale
l2
l2 <- list(list(2, start = list(c=3,d=4)), control=list(parscale=c(a=1,b=2)))
l2
l2$control$parscale
l2$control$parscale$a
l2 <- c(list(2, start = list(c=3,d=4)), control=list(parscale=c(a=1,b=2)))
l2$control$parscale$a
fitweibull(dt, start.value = c(shape=0.7, scale=1.8), control=list(parscale=c(shape=0.79, scale=1.99)))
fitweibull(dt, start.value = c(shape=0.7, scale=1.8), control=list(parscale=list(shape=0.79, scale=1.99)))
fitweibull(dt, start.value = c(shape=0.7, scale=1.8), control=list(parscale=c(shape=0.79, scale=1.99)))
source('~/Downloads/fitweibull.r')
debugSource('~/Downloads/fitweibull.r')
fitweibull2(dt, start.value = c(shape=0.7, scale=1.8), control=list(parscale=c(shape=0.79, scale=1.99)))
dots
...
c(list(LL, start = list(shape = ka,  scale = theta), data = list(x = x)), ...)
list(LL, start = list(shape = ka,  scale = theta), data = list(x = x), ...)
t1=c(list(LL, start = list(shape = ka,  scale = theta), data = list(x = x)), ...)
t2=list(LL, start = list(shape = ka,  scale = theta), data = list(x = x), ...)
t3=c(list(LL, start = list(shape = ka,  scale = theta), data = list(x = x)), dots)
class(t1$control)
class(t2$control)
class(t3$control)
fitweibull(dt, start.value = c(shape=0.7, scale=1.8), control=list(parscale=c(shape=0.79, scale=1.99)))
set.seed(42)
dt <- rweibull(100, shape = 0.8, scale = 2)
fitweibull(dt, start.value = c(shape=0.7, scale=1.8), control=list(parscale=c(shape=0.79, scale=1.99)))
fitweibull
set.seed(42)
dt <- rweibull(100, shape = 0.8, scale = 2)
fitweibull(dt)
install.packages(c("chron", "httr", "igraph", "manipulate", "rgdal"))
install.packages(c("curl", "goftest", "igraph", "manipulate", "maps", "phangorn", "phytools", "polspline", "R6", "raster", "RCurl", "registry", "spatstat", "stringi", "subplex", "XML"))
install.packages(c("adehabitatHR", "adehabitatHS", "adehabitatLT", "adehabitatMA", "manipulate", "multcomp", "mvtnorm", "polspline", "Rcpp"))
library(vegan)
data(BCI)
View(BCI)
setwd("/home/mario/Git/Scripts/VariancePartition/")
library(vegan)
library(packfor)
library(spacemakeR)
library(spdep)
data(BCI)
BCI.env <- read.delim ('http://www.davidzeleny.net/anadat-r/lib/exe/fetch.php?media=data:bci.env.txt')
View(BCI.env)
View(BCI.env)
ll <- BCI.env[ ,2:3]
View(ll)
spp <- BCI
env <- BCI.env[ ,-(1:3)]
View(env)
rm(BCI, BCI.env)
rownames(ll) <- rownames(spp) <- rownames(env) <- paste("site", 1:dim(ll)[1], sep="_")
View(env)
spp.std <- decostand(spp[ ,apply(spp > 0, 2, sum) > 1], "hellinger")
env.std <- decostand(env, "standardize")
ll.nb <- tri2nb(ll)
ll.wgh <- nb2listw(ll.nb, style = "B")
mem <- scores.listw(ll.wgh)
colnames(mem$vectors) <- paste("MEM_", 1:ncol(mem$vectors), sep = "")
colnames(mem$vectors)
rownames(mem$vectors) <- rownames(ll)
mem.test <- test.scores(mem, ll.wgh, 999)
mem.sel <- list(values = mem$values[mem.test[ ,"pval"] < 0.05],
vectors = mem$vectors[ ,mem.test[ ,"pval"] < 0.05])
dim(mem.sel$vectors)
rda.spa <- rda(spp.std, mem.sel$vectors)
rda.spa.sel <- forward.sel(spp.std, mem.sel$vectors, adjR2thresh = RsquareAdj(rda.spa)$adj.r.squared)
#Checking selected MEMs for species data
rda.spa.sel
rda.env <- rda(spp.std, env.std)
rda.env.sel <- forward.sel(spp.std, env.std, adjR2thresh = RsquareAdj(rda.env)$adj.r.squared)
rda.env.sel
spatial <- list(values = mem.sel$values[colnames(mem.sel$vectors) %in% rda.spa.sel$variables],
vectors = mem.sel$vectors[ ,colnames(mem.sel$vectors) %in% rda.spa.sel$variables])
# Checking selected MEMs
dim(spatial$vectors)
# Filter environment data to selected environmental variables in RDA
environment <- env.std[ ,rda.env.sel$variables]
# Checking selected environmental variables
dim(environment)
all.varpart <- varpart(spp.std, environment, spatial$vectors)
all.varpart
plot(all.varpart, Xnames = c("environment", "spatial"))
rda.env.spa <- rda(spp.std, environment, spatial$vectors)
env.aov <- anova(rda.env.spa)
env.aov
rda.spa.env <- rda(spp.std, spatial$vectors, environment)
spa.aov <- anova(rda.spa.env)
spa.aov
source('~/Git/r-functions/correlogI/correlogI.r')
rm(correlogI)
source(url(http://raw.githubusercontent.com/MarioJose/r-functions/master/correlogI/correlogI.r))
source(url("http://raw.githubusercontent.com/MarioJose/r-functions/master/correlogI/correlogI.r"))
url("https://raw.githubusercontent.com/MarioJose/r-functions/master/correlogI/correlogI.r")
url("http://raw.githubusercontent.com/MarioJose/r-functions/master/correlogI/correlogI.r")
source(url("http://raw.githubusercontent.com/MarioJose/r-functions/master/correlogI/correlogI.r"))
source(url("http://raw.githubusercontent.com/MarioJose/r-functions/master/correlogI/correlogI.r", open = "r"))
source('~/Git/r-functions/correlogI/correlogI.r')
nc <- round(1 + (1/log10(2)) * log10(length(dist(ll)[upper.tri(dist(ll), diag = FALSE)])), 0)
pred.spa <- predict(rda(spp.std, cbind(environment, spatial$vectors))) - predict(rda(spp.std, environment))
R <- cor(pred.spa)
corr <- matrix(NA, nrow = nc, ncol = dim(pred.spa)[2], dimnames = list(1:nc, names(pred.spa)))
for(i in 1:dim(corr)[2]){
corr[ ,i] <- correlogI(pred.spa[ ,i], ll)$result$I
}
rm(i)
M <- matrix(NA, nrow = dim(pred.spa)[2], dim(pred.spa)[2], dimnames = list(names(pred.spa), names(pred.spa)))
# 3D array with x and y to species and z to distance classes
tmp <- array(NA, c(dim(pred.spa)[2],dim(pred.spa)[2],nc))
for(k in 1:nc){
tmat <- matrix(rep(corr[k, ], times = dim(pred.spa)[2]), nrow = dim(pred.spa)[2], ncol = dim(pred.spa)[2])
tmp[, , k] <- abs(tmat - t(tmat)) / nc
}
M[] <- apply(tmp, c(1,2), sum)
rm(k, tmp)
View(corr)
mantel(M, R)
source('~/Git/r-functions/correlogI/correlogI.r')
data(BCI)
BCI.env <- read.delim ('http://www.davidzeleny.net/anadat-r/lib/exe/fetch.php?media=data:bci.env.txt')
ll <- BCI.env[ ,2:3]
spp <- BCI
env <- BCI.env[ ,-(1:3)]
rownames(ll) <- rownames(spp) <- rownames(env) <- paste("site", 1:dim(ll)[1], sep="_")
rm(BCI, BCI.env)
View(spp)
spp.std <- decostand(spp[ ,apply(spp > 0, 2, sum) > 1], "hellinger")
env.std <- decostand(env, "standardize")
ll.nb <- tri2nb(ll)
ll.wgh <- nb2listw(ll.nb, style = "B")
mem <- scores.listw(ll.wgh)
colnames(mem$vectors) <- paste("MEM_", 1:ncol(mem$vectors), sep = "")
rownames(mem$vectors) <- rownames(ll)
mem.test <- test.scores(mem, ll.wgh, 999)
mem.sel <- list(values = mem$values[mem.test[ ,"pval"] < 0.05],
vectors = mem$vectors[ ,mem.test[ ,"pval"] < 0.05])
rda.spa <- rda(spp.std, mem.sel$vectors)
rda.spa.sel <- forward.sel(spp.std, mem.sel$vectors, adjR2thresh = RsquareAdj(rda.spa)$adj.r.squared)
rda.spa.sel
rda.env <- rda(spp.std, env.std)
rda.env.sel <- forward.sel(spp.std, env.std, adjR2thresh = RsquareAdj(rda.env)$adj.r.squared)
rda.env.sel
spatial <- list(values = mem.sel$values[colnames(mem.sel$vectors) %in% rda.spa.sel$variables],
vectors = mem.sel$vectors[ ,colnames(mem.sel$vectors) %in% rda.spa.sel$variables])
# Checking selected MEMs
dim(spatial$vectors)
environment <- env.std[ ,rda.env.sel$variables]
dim(environment)
all.varpart <- varpart(spp.std, environment, spatial$vectors)
nc <- round(1 + (1/log10(2)) * log10(length(dist(ll)[upper.tri(dist(ll), diag = FALSE)])), 0)
pred.spa <- predict(rda(spp.std, cbind(environment, spatial$vectors))) - predict(rda(spp.std, environment))
View(pred.spa)
R <- cor(pred.spa)
View(R)
corr <- matrix(NA, nrow = nc, ncol = dim(pred.spa)[2], dimnames = list(1:nc, names(pred.spa)))
View(corr)
View(corr)
View(pred.spa)
names(pred.spa)
colnames(pred.spa)
corr <- matrix(NA, nrow = nc, ncol = dim(pred.spa)[2], dimnames = list(1:nc, colnames(pred.spa)))
View(corr)
i=1
pred.spa[ ,i]
correlogI(pred.spa[ ,i], ll)$result$I
View(ll)
plot(ll)
library(vegan)
library(packfor)
library(spacemakeR)
library(spdep)
debugSource('~/Git/r-functions/correlogI/correlogI.r')
corr[ ,i] <- correlogI(pred.spa[ ,i], ll)$result$I
View(D)
d
View(res)
View(w)
View(res)
View(res)
1 / res$W[cl]
res$W[cl]
View(w)
View(D)
max(D) / nc
d
View(dt)
getwd()
write.table(dt, "ll.csv", sep=";")
x
write.table(x, "x.csv", sep=";")
View(res)
debugSource('~/Git/r-functions/correlogI/correlogI.r')
corr[ ,i] <- correlogI(pred.spa[ ,i], ll)$result$I
source('~/Git/r-functions/correlogI/correlogI.r')
corr[ ,i] <- correlogI(pred.spa[ ,i], ll)$result$I
View(corr)
View(corr)
source('~/.active-rstudio-document')
correlogI(pred.spa[ ,i], ll)$result$I
for(i in 1:dim(corr)[2]){
corr[ ,i] <- correlogI(pred.spa[ ,i], ll)$result$I
}
rm(i)
View(corr)
k=1
tmat <- matrix(rep(corr[k, ], times = dim(pred.spa)[2]), nrow = dim(pred.spa)[2], ncol = dim(pred.spa)[2])
View(tmat)
corr[1,] <- NA
View(corr)
tmat <- matrix(rep(corr[k, ], times = dim(pred.spa)[2]), nrow = dim(pred.spa)[2], ncol = dim(pred.spa)[2])
View(tmat)
k=2
tmat <- matrix(rep(corr[k, ], times = dim(pred.spa)[2]), nrow = dim(pred.spa)[2], ncol = dim(pred.spa)[2])
View(tmat)
tmp <- array(NA, c(dim(pred.spa)[2],dim(pred.spa)[2],nc))
for(k in 1:nc){
tmat <- matrix(rep(corr[k, ], times = dim(pred.spa)[2]), nrow = dim(pred.spa)[2], ncol = dim(pred.spa)[2])
tmp[, , k] <- abs(tmat - t(tmat)) / nc
}
M[] <- apply(tmp, c(1,2), sum)
M <- matrix(NA, nrow = dim(pred.spa)[2], dim(pred.spa)[2], dimnames = list(names(pred.spa), names(pred.spa)))
M[] <- apply(tmp, c(1,2), sum)
View(M)
View(tmat)
tmp
1-NA
source('~/Git/r-functions/correlogI/plot.correlogI.r')
plot.correlogI(pred.spa[ ,i])
plot.correlogI(pred.spa[ ,1])
plot.correlogI(correlogI(pred.spa[ ,1]))
plot.correlogI(correlogI(pred.spa[ ,1], ll))
source('~/Git/r-functions/correlogI/correlogI.r')
correlogI(pred.spa[ ,i], ll)$result$I
i=1
correlogI(pred.spa[ ,i], ll)$result$I
warnings()
source('~/Git/r-functions/correlogI/correlogI.r')
correlogI(pred.spa[ ,i], ll)$result$I
corr <- matrix(NA, nrow = nc, ncol = dim(pred.spa)[2], dimnames = list(1:nc, colnames(pred.spa)))
for(i in 1:dim(corr)[2]){
corr[ ,i] <- correlogI(pred.spa[ ,i], ll)$result$I
}
rm(i)
View(corr)
View(corr)
M <- matrix(NA, nrow = dim(pred.spa)[2], dim(pred.spa)[2], dimnames = list(names(pred.spa), names(pred.spa)))
# 3D array with x and y to species and z to distance classes
tmp <- array(NA, c(dim(pred.spa)[2],dim(pred.spa)[2],nc))
for(k in 1:nc){
tmat <- matrix(rep(corr[k, ], times = dim(pred.spa)[2]), nrow = dim(pred.spa)[2], ncol = dim(pred.spa)[2])
tmp[, , k] <- abs(tmat - t(tmat)) / nc
}
M[] <- apply(tmp, c(1,2), sum)
View(M)
M[] <- apply(tmp, c(1,2), sum, na.rm = TRUE)
View(M)
rm(k, tmp)
mantel(M, R)
plot(M~R)
data(BCI)
BCI.env <- read.delim ('http://www.davidzeleny.net/anadat-r/lib/exe/fetch.php?media=data:bci.env.txt')
# Using our variable names to data
ll <- BCI.env[ ,2:3]
spp <- BCI
env <- BCI.env[ ,-(1:3)]
# Naming rows with sites names
rownames(ll) <- rownames(spp) <- rownames(env) <- paste("site", 1:dim(ll)[1], sep="_")
# Removing original data from dashboard
rm(BCI, BCI.env)
ll <- read.table(file.choose(), row.names = 1, header = T, sep = ",")
spp.std <- decostand(spp[ ,apply(spp > 0, 2, sum) > 1], "hellinger")
# Standardization of environmental data
env.std <- decostand(env, "standardize")
ll.nb <- tri2nb(ll)
# Spatial weights to neighbour list. See Borcard et al. (2011) for details.
ll.wgh <- nb2listw(ll.nb, style = "B")
# Compute Moran's eigenvectors
mem <- scores.listw(ll.wgh)
colnames(mem$vectors) <- paste("MEM_", 1:ncol(mem$vectors), sep = "")
# Name rows
rownames(mem$vectors) <- rownames(ll)
mem.test <- test.scores(mem, ll.wgh, 999)
# Select significant MEMs at 0.05 confidence level
mem.sel <- list(values = mem$values[mem.test[ ,"pval"] < 0.05],
vectors = mem$vectors[ ,mem.test[ ,"pval"] < 0.05])
# Checking how many MEMs was selected (rows, columns)
dim(mem.sel$vectors)
rda.spa <- rda(spp.std, mem.sel$vectors)
rda.spa.sel <- forward.sel(spp.std, mem.sel$vectors, adjR2thresh = RsquareAdj(rda.spa)$adj.r.squared)
#Checking selected MEMs for species data
rda.spa.sel
rda.env <- rda(spp.std, env.std)
rda.env.sel <- forward.sel(spp.std, env.std, adjR2thresh = RsquareAdj(rda.env)$adj.r.squared)
#Checking selected MEMs for environmental data
rda.env.sel
spatial <- list(values = mem.sel$values[colnames(mem.sel$vectors) %in% rda.spa.sel$variables],
vectors = mem.sel$vectors[ ,colnames(mem.sel$vectors) %in% rda.spa.sel$variables])
# Checking selected MEMs
dim(spatial$vectors)
# Filter environment data to selected environmental variables in RDA
environment <- env.std[ ,rda.env.sel$variables]
# Checking selected environmental variables
dim(environment)
all.varpart <- varpart(spp.std, environment, spatial$vectors)
all.varpart
par(mar=c(1,1,1,1), cex=1.4)
plot(all.varpart, Xnames = c("environment", "spatial"))
pdf("varpart.pdf", 10, 5)
par(mar=c(1,1,1,1), cex=1.4)
plot(all.varpart, Xnames = c("environment", "spatial"))
dev.off()
